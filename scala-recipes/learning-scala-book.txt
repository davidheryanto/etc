============================================================
Chapter 6
============================================================

Create list of 20 odd numbers: with filter, map
------------------------------------------------------------
for (i <- 0L to 9L; j = i * 2 + 1) yield j
0L to 20L filter (_ % 2 == 1)
0L to 9L map (_ * 2 + 1)

Find factors of a list of numbers
------------------------------------------------------------
def factors(x: Int) = { 2 to (x-1) } filter (x % _ == 0)
def uniqueFactors(l: Seq[Int]) = l flatMap factors

uniqueFactors(List(9,11,13,15))  // List(3, 3, 5)

Take first 3 items in a list
------------------------------------------------------------
val chars = ('a' to 'f').toList

// Use built-in take
def first[A](items: List[A], count:Int): List[A] = items take count
first(chars, 3)

// Bad performance with long non-indexed collections like LinkedList
def first_loop[A](items: List[A], count:Int): List[A] = {
  val l = for (i <- 0 until count) yield items(i)
  l.toList
}
first_loop(chars, 3)

// Using foldLeft
def first_foldLeft[A](items: List[A], count:Int): List[A] = {
  items.foldLeft[List[A]](Nil) { (a: List[A], i: A) =>
    // Initially a is Nil (List with 0 items)
    // Then we slowly add i
    if (a.size >= count) a else i :: a
  }.reverse
}
first_foldLeft(chars, 3)

// Old-fashioned recursive func
def first_rec[A](items: List[A], count: Int): List[A] = {
  if (count > 0 && items.tail != Nil) items.head :: first_rec(items.tail, count - 1)
  else Nil
}
first(chars, 3)

Returns longest string in the list
------------------------------------------------------------
// Use collections library method
def longest(l: List[String]): String = l.sortBy(0 - _.size).head

val names = List("Harry", "Hermione", "Ron", "Snape")
longest(names)

// Use fold
def longest_fold(l: List[String]): String = {
  l.fold("")((a,i) => if (a.size < i.size) i else a)
}
longest_fold(names)

// Use reduce
def longest_reduce(l: List[String]): String = {
  l.reduce((a,i) => if (a.size < i.size) i else a)
}
longest_reduce(names)

// Use custom comparator
def greatest[A](l: List[A], max: (A, A) => A): A = {
  l reduce ((a,i) => max(a,i))
}
greatest[String](names, (x,y) => if(x.size > y.size) x else y)

Recursive reverse
------------------------------------------------------------
def reverse[A](src: List[A], dest: List[A] = Nil): List[A] = {
  if (src == Nil) dest else reverse(src.tail, src.head :: dest)
}

Split a list into 2 lists: 1st list contains all palindromes, 2nd the rest
------------------------------------------------------------
// Use partition function
def splitPallies(l: List[String]) = l partition(s => s == s.reverse)
val pallies = List("Hi", "otto", "yo", "racecar")
splitPallies(pallies)

// Partition is actually like a reduction function. Reduces a list to tuple of 2 lists
def splitPallies2(l: List[String]) = {
  l.foldLeft((List[String](), List[String]())) {
    (a,i) => if (i == i.reverse) (i :: a._1, a._2) else (a._1, i :: a._2)
  }
}
splitPallies(pallies)

Parsing XML and processing List
------------------------------------------------------------
val APPID = "paste your openweather API key"

// Newer API no longer include new line after each xml tag.
// In this case, reindent the xml and save to a file. Hint: Can use SublimeText 'Indent XML' package
// val url = s"http://api.openweathermap.org/data/2.5/forecast?mode=xml&lat=55&lon=0&APPID=$APPID"
// val l: List[String] = io.Source.fromURL(url).getLines.toList
val l = io.Source.fromFile("/home/user/out.xml").getLines.toList

val k = l map (_.trim)

// Get the city and country name
def getChild(tag: String) = k filter (_ contains s"<$tag>") mkString "" replaceAll(".*>(\\w+)</.*", "$1")

val cityName = getChild("name")
val countryCode = getChild("country")

// Find no of time segments
val segments = l count (_ contains "</time>")
// Alternatively, l.filter(_ contains "</time>").size

// Getting weather description: forecast -> time -> symbol[name]
def attribute(tag: String, attr: String) = {
  k.filter(_ contains s"<$tag").filter(_ contains s"$attr=")
    .map { s => s.replaceAll(s""".*$attr="([^"]+)".*""", "$1") }
}
val names = attribute("symbol", "name")
val forecast = attribute("time", "from") zip attribute("symbol", "name") take 4

{
  println("12 hour forecast")
  forecast foreach { case (time, desc) =>
    val when = time.replaceAll("""T(\d+).*""", """ at $100""")
    println(s"$when | $desc")
  }
}

// Print all unique weather descriptions
val terms = attribute("symbol", "name").distinct.sorted

// Create a map from symbol to description
val symbolsToDescription = attribute("symbol", "number") zip attribute("symbol", "name")
val symMap = symbolsToDescription.distinct.map(t => t._1.toInt -> t._2).toMap
println("Light rain? Yup, " + symMap(500))

// Min max temp
val maxK = attribute("temperature", "max").map(_.toDouble).max
val minK = attribute("temperature", "max").map(_.toDouble).min

// Average temp
val temperatures = attribute("temperature", "value").map(_.toDouble)
val avg_temperatures = temperatures.sum / temperatures.size
