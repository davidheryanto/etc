===========
Extra Info
===========
https://deis.com/blog/2016/kubernetes-illustrated-guide/

Good links about Kubernetes networking:
https://cloud.google.com/solutions/prep-container-engine-for-prod

============================================================
					    Cheat Sheet
https://kubernetes.io/docs/user-guide/kubectl-cheatsheet/
============================================================

kubectl create -f ./my1.yaml -f ./my2.yaml
kubectl create -f ./dir

============================================================

minikube version
minikube start

kubectl version
kubectl cluster-info
kubectl get nodes

kubectl run
kubectl run kubernetes-bootcamp --image=docker.io/jocatalin/kubernetes-bootcamp:v1 --port=8080
kubectl run ${DEPLOYMENT_NAME} --image=debian:stretch -i --tty
kubectl run nginx-deployment -i --tty --image=nginx --port=80
kubectl get deployments

kubectl proxy

kubectl get pods
# Show more info for pods, e.g. the IP address
kubectl get pods -o wide
kubectl describe pods

# Filter by selector, e.g. there's spec.selector.component: myapp
kubectl get svc -l component=myapp

# Filter with jsonpath: https://kubernetes.io/docs/reference/kubectl/jsonpath/
kubectl get pods -o=jsonpath='{@}'
# e.g. get the NodePort
kubectl get svc -l component=myapp -o jsonpath='{.items[1].spec.ports[0].nodePort}'

# Cheatsheet: https://github.com/fabric8io/kansible/blob/master/vendor/k8s.io/kubernetes/docs/user-guide/kubectl-cheatsheet.md

kubectl logs $POD_NAME

kubectl exec $POD_NAME env
kubectl exec -ti $POD_NAME bash

# kubectl exec if more than one container in a pod
kubectl exec -it my-pod --container main-app -- /bin/bash

kubectl config view

# Context: list, check current, switch
# Config location: ~/.kube/config
kubectl config view | grep -A1 " context:"
kubectl config view -o jsonpath='{.contexts[*].name}'

kubectl config current-context
kubectl config use-context CONTEXT_NAME

kubectl get namespaces --show-labels

kubectl port-forward POD_NAME 8080:8080

# View pod events
kubectl describe pod POD_NAME

Secrets & Configmaps
----------------------
kubectl create secret generic SECRET_NAME --from-file=SECRET_FILEPATH
kubectl create secret generic SECRET_NAME --from-literal=username=USERNAME --from-literal=password=PASSWORD

kubectl create secret generic tls-certs --from-file=tls/
kubectl describe secrets tls-certs  # Verify

kubectl create configmap nginx-proxy-conf --from-file=nginx/proxy.conf
kubectl describe configmap nginx-proxy-conf  # More details

# Get yaml representation of current config file
kubectl get configmap CONFIG_NAME -o yaml

# Updating existing configmap
# https://stackoverflow.com/questions/38216278/update-k8s-configmap-or-secret-without-deleting-the-existing-one
# Can use apply (rather than replace) to 'create or update'
kubectl create configmap CONFIGMAP_NAME --from-file FILE_PATH -o yaml --dry-run | kubectl apply -f -
# Old method
kubectl create configmap CONFIGMAP_NAME --from-file FILE_PATH -o yaml --dry-run | kubectl replace -f -

# Get the yaml that will produce existing deployment
# https://github.com/kubernetes/kubernetes/issues/24873
kubectl get deploy [DEPLOYMENT_NAME] -o yaml --export
# Think for boolean parameter it's optional to provide truthy argument
kubectl get deploy [DEPLOYMENT_NAME] -o yaml --export=true  

# Get the yaml that produce existing cluster
kubectl get all --export -o yaml

Setting namespace to config
------------------------------------------------------------

https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/

kubectl config set-context $(kubectl config current-context) --namespace=<insert-namespace-name-here>
# Validate it
kubectl config view | grep namespace:

# Alternatively, vim ~/.kube/config
- context:
    cluster: CLUSTER_NAME
    namespace: SET_YOUR_DEFAULT_NAMESPACE


Flow
============================================================
kubectl delete deployments/DEPLOYMENT_NAME services/SERVICE_NAME
kubectl create -f DEPLOYMENT_SERVICE_YAML

Deployment 
============================================================
# For initial deployment and UPDATE in deployment
kubectl apply -f deployment.yaml

# Delete deployment by name
kubectl get deployments  | grep ${DEPLOYMENT_NAME} | awk '{print $1}' | xargs kubectl delete deployments

Services
=========================================
- Match by labels and selectors
  e.g. 
  - dev, test, production labels
  - version, tags

kubectl get services
kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080
kubectl describe services/kubernetes-bootcamp

kubectl expose deployment hello-node --type=LoadBalancer
kubectl get services
# To access on minikube: minikube service hello-node

Using labels
------------
kubectl get deployments
kubectl describe deployment
kubectl get pods -l run=kubernetes-bootcamp
kubectl get services -l run=kubernetes-bootcamp

Applying label
--------------
kubectl label pod $POD_NAME app=v1
kubectl get pods -l app=v1

Deleting services
=========================================
kubectl delete service -l run=kubernetes-bootcamp
kubectl get services

Scaling
============================================================
- By setting no of replicas

# Check the desired, current, available pods
kubectl get deployments

kubectl scale deployments/kubernetes-bootcamp --replicas=4

kubectl get pods -o wide
kubectl describe deployments/kubernetes-bootcamp

Load balancing
--------------
kubectl describe services/kubernetes-bootcamp
# Can check that requests to $HOST:$PORT are handled by different pods

Updating
============================================================
Rolling updates
- Update an application (container image update)
- Rollback
- CI and CD (zero downtime)

kubectl get deployments
kubectl get pods
kubectl describe pods

kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2

kubectl get pods  # See update status
curl $HOST:$PORT  # Check that it's new version
kubectl rollout status deployments/kubernetes-bootcamp  # Alternatively, to check

# Show diff between deployment revisions
diff <(kubectl rollout history deployment/[MY_DEPLOYMENT] --revision=1) <(kubectl rollout history deployment/[MY_DEPLOYMENT] --revision=2)

# Show diff between helm releases
# https://github.com/databus23/helm-diff/issues/6
sdiff -s -w 80 <(helm get $RELEASE --revision $NEW_REVISION) <(helm get $RELEASE --revision $OLD_REVISION)

Rolling back
------------
kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v10  # Update to non-existent version
kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v1  # Rollback

Logging
============================================================
kubectl logs [-f] $POD_NAME


Deleting
============================================================
kubectl delete service hello-node
kubectl delete deployment hello-node

Cleanup
-------
kubectl delete pods healthy-monolith monolith secure-monolith
kubectl delete services monolith auth frontend hello
kubectl delete deployments auth frontend hello
kubectl delete secrets tls-certs
kubectl delete configmaps nginx-frontend-conf nginx-proxy-conf



============================================================
				   Minikube
============================================================
eval $(minikube docker-env)  # Use docker daemon
eval $(minikube docker-env -u)  # Stop using


============================================================
						Udacity
============================================================

Provision kubernetes cluster
----------------------------
gcloud container clusters create k0 

kubectl create -f pods/monolith.yaml
kubectl get pods
kubectl describe pods monolith

kubectl port-forward monolith 10080:80
kubectl logs monolith
kubectl exec monolith --stdin --tty -c monolith /bin/sh

- Readiness
- Liveness: restart container

  readinessProbe:
    httpGet:
      path: /readiness
      port: 81
      scheme: HTTP
    initialDelaySeconds: 5
    timeoutSeconds: 1

  livenessProbe:
    httpGet:
      path: /healthz
      port: 81
      scheme: HTTP
    initialDelaySeconds: 5
    periodSeconds: 15
    timeoutSeconds: 5


Service discovery
------------------
spec:
  selector:
    app: "monolith"
    secure: "enabled"
  ports:
  - protocol: "TCP"
    port: 443
    targetPort: 443
    nodePort: 31000
  type: NodePort

kubectl create -f services/monolith.yaml 
gcloud compute firewall-rules create allow-monolith-nodeport --allow=tcp:31000
gcloud compute instances list

# Troubleshoot endpoints not available
kubectl get pods -l "app=monolith"
kubectl get pods -l "app=monolith,secure=enabled"

# Check pod label
kubectl describe pods secure-monolith | grep Labels
# Add pod label
kubectl label pods secure-monolith "secure=enabled"

Deployment
----------
kubectl create -f deployments/hello.yaml

kubectl create -f deployments/auth.yaml
kubectl describe deployments auth
kubectl create -f services/auth.yaml
kubectl create -f services/hello.yaml

kubectl create configmap nginx-frontend-conf --from-file=nginx/frontend.conf
kubectl create -f deployments/frontend.yaml 
kubectl create -f services/frontend.yaml
kubectl get service frontend

# Remember to open port at the external firewall

Scaling
-------
kubectl get replicasets
vim deployments/hello.yaml  # Increment value of replicas
kubectl apply -f deployments/hello.yaml
kubectl get replicasets

Rolling update
--------------
vim deployments/auth.yaml  # Update image su version 2.0.0
kubectl apply -f deployments/auth.yaml

Adding secrets
------------------------------------------------------------
# For imagePullSecrets in pod.yaml
kubectl create secret docker-registry image-pull-secret --docker-server "https://asia.gcr.io" --docker-username _json_key --docker-email not@val.id --docker-password="$(cat service-account-one-liner.json)"


RBAC
============================================================
Set user as cluster-admin
https://github.com/kubernetes/ingress-nginx/issues/1663

kubectl create clusterrolebinding cluster-admin-binding \
  --clusterrole cluster-admin \
  --user $(gcloud config get-value account)


Bug
============================================================
https://github.com/kubernetes/dashboard/wiki/FAQ#i-am-seeing-404-errors-when-trying-to-access-dashbord-dashboard-resources-can-not-be-loaded

Error:
- clusterroles.rbac.authorization.k8s.io "USER" is forbidden: attempt to grant extra privileges
Solution:
- https://stackoverflow.com/questions/45281998/istio-installation-on-gke-failed-with-clusterroles-rbac-authorization-k8s-io-i
- Not sure why it works

Sample deployment.yaml
============================================================
apiVersion: apps/v1beta2 (For at least Kubernetes 1.9 can use apps/v1)
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      initContainers:
      - name: init-sysctl
        image: busybox:1.27.2
        command:
        - sysctl
        - -w
        - vm.max_map_count=262144
        securityContext:
          privileged: true

      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
        env:
        - name: KEY
          value: "My value"

--- 

kind: Service
apiVersion: v1
metadata:
  [namespace: demo]
  name: nginx
  labels:
    app: nginx
spec:
  type: ClusterIP
  ports:
  - port: 80
    protocol: TCP
    name: http
  selector:
    app: nginx

============================================================
Sample pod with configmap
============================================================
apiVersion: v1
kind: Pod
metadata:
  name: deleteme
spec:
  containers:
    - name: deleteme
      image: debian:stretch
      command: ["bash -c sleep infinity"]
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        name: deleteme
