# Frameworks for REST services
============================================================
============================================================
Play
Spray -> Going to be replaced with Akka-HTTP
http4s (functional idiom, use scalaz-streams)

============================================================
============================================================

------------------------------------------------------------
Notes from Learning Scala Book
------------------------------------------------------------

# Checking type
============================================================
x.isInstanceOf[Int]

# String interpolation
==============================================================
println(s"Pi, using 355/113, is about $approx." )

printf
------
f"I wrote a new $item%.3s today"  # Print first 3 char of item
f"Enjoying this $item ${355/113.0}%.5f times today"

# Regex
==============================================================
"Froggy went a' courting" matches ".*courting"
"milk, tea, muck" replaceAll ("m[^ ]+k", "coffee")
"milk, tea, muck" replaceFirst ("m[^ ]+k", "coffee")

val input = "Enjoying this apple 3.14159 times today"
val pattern = """.* apple ([\d.]+) times .*""".r
val pattern(amountText) = input
val amount = amountText.toDouble

# Tuple: 1-based index
val info = (5, "Korben", true)
val name = info._2
# Key-value pairs in tuple
val red = "red" -> "0xff0000"

# If..Else
==============================================================
if (<Boolean expression>) <expression>

if (<Boolean expression>) <expression>
else <expression>

val max = if (x > y) x else y

# Match
==============================================================
<expression> match {
	case <pattern match> => <expression>
	[case...]
}

val x = 10; val y = 20
val max = x > y match {
 case true => x
 case false => y
}

val status = 500
val message = status match {
 case 200 => "ok"
 case 400 => {
   println("ERROR - we called the service incorrectly")
   "error"
 }
 case 500 => {
   println("ERROR - the service encountered an error")
   "error"
 }
}

# A pattern alternative: any of the patterns
==============================================================
case <pattern 1> | <pattern 2> .. => <one or more expressions>

val kind = day match {
  case "MON" | "TUE" | "WED" | "THU" | "FRI" => "weekday"
  case "SAT" | "SUN" => "weekend"
}

# Matching with Wildcard Patterns
==============================================================
val message = "Value Binding"
val status = message match {
  case "Ok" => 200
  case other => {
    println(s"Couldn't parse $other")
    -1
  }
}

val status = message match {
  case "Ok" => 200
  case _ => {
    println(s"Couldn't parse $message")
    -1
  }
}

# Matching with Pattern Guards
==============================================================
val response: String = null
response match {
  case s if s != null => println(s"Received '$s'")
  case s => println("Error! Received a null response")
}

# Matching Types with Pattern Variables
==============================================================
case <identifier>: <type> => <one or more expressions>

val x: Int = 12180
val y: Any = x
y match {
  case x: String => s"'x'"
  case x: Double => f"$x%.2f"
  case x: Float => f"$x%.2f"
  case x: Long => s"${x}l"
  case x: Int => s"${x}i"
}

# Loops
==============================================================
Iterating, filtering, value binding

<starting integer> [to|until] <ending integer> [by increment]

for (<identifier> <- <iterator>) [yield] [<expression>]

for (x <- 1 to 7) { println(s"Day $x:") } 

val days = for (x <- 1 to 7) yield { s"Day $x:" }
for (day <- days) print(day + ", ")

# Iterator Guard
============================================================
for (<identifier> <- <iterator> if <Boolean expression>) ...

val threes = for (i <- 1 to 20 if i % 3 == 0) yield i

val quote = "Faith,Hope,,Charity"
for {
	t <- quote.split(",")
	if t != null
	if t.size > 0
}
{ println(t) }

# Nested Iterators
============================================================
for { x <- 1 to 2 
      y <- 1 to 3 }
  { print(s"($x, $y) " ) }

# Value Binding: temporary variables inside expression block for current iter
============================================================
for (<identifier> <- <iterator>; <identifier> = <expression>) ...

val powersOf2 = for (i <- 0 to 8; pow = 1 << i) yield pow

# While and Do/While
============================================================
while (<Boolean expression>) statement

var x = 10; while (x > 0) x -= 1

val x = 0
do println(s"Here I am, x = $x") while (x > 0)

# Functions
============================================================
def <identifier>(<identifier>: <type>[, ... ]): <type> = <expression>

def multiplier(x: Int, y: Int): Int = { x * y }

Procedure: No return value
--------------------------
def log(d: Double): Unit = println(f"Got value $d%.2f")

Tail Recursive
--------------
@annotation.tailrec
def power(x: Int, n: Int, t: Int = 1): Int = {
  if (n < 1) t
  else power(x, n-1, x*t)
}

Calling Functions with Named Parameters
---------------------------------------
def greet(prefix: String, name: String) = s"$prefix $name"

val greeting2 = greet(name = "Brown", prefix = "Mr")

Vararg
------
def sum(items: Int*): Int = {
  var total = 0
  for (i <- items) total += i
  total
}

Parameter Groups
----------------
def max(x: Int)(y: Int) = if (x > y) x else y

val larger = max(20)(39)

Type Parameters
---------------
def <function-name>[type-name](parameter-name>: <type-name>): <type-name>...

def identity[A](a: A): A = a

val s: String = identity[String]("Hello")
val d: Double = identity[Double](2.717)

# Can infer the parameter type and returned type
val s = identity("Hello")  # s: String = Hello

Methods and Operators
---------------------
val d = 65.34
d.round
d.floor
d.compare(18.0)
d.+(2.7231)

Operator Notation:
d compare 18.0
d + 2.721
"staring" substring (1,4)

============================================================
First Order Functions
============================================================

Function Type:
([<type>, ...]) => <type>

def double(x: Int): Int = x*2
val myDouble: (Int) => Int = double
val myDouble = double _  // Equivalent

def max(a: Int, b: Int) = if (a > b) a else b
val maximize: (Int, Int) => Int = max

// Function with no input
def logStart() = "=" * 50 + "\nStarting NOW\n" + "=" * 50
val start: () => String = logStart
println(start())

Higher-order functions
------------------------------------------------------------
A higher-order function is a function that has a value with a function type as an input parameter or return value.

// Only execute function f if s is not null
def safeStringOp(s: String, f: String => String) = {
  if (s != null) f(s) else s
}
def reverser(s: String) = s.reverse
safeStringOp(null, reverser)

Function Literals
------------------------------------------------------------
([<identifier>: <type>, ... ]) => <expression>

val doubler = (x: Int) => x * 2
val start = () => "=" * 50 + "\nStarting NOW\n" + "=" * 50

// Can define it inside of higher-order func invocation
safeStringOp("Ready", (s: String) => s.reverse)
safeStringOp("Ready", s => s.reverse)  // The type in function literal can be ignored, because it's already defined in safeStringOp

Placeholder syntax
------------------------------------------------------------
safeStringOp("Ready", _.reverse)

// Using type parameter
def tripleOp[A,B](a: A, b: A, c: A, f: (A, A, A) => B) = f(a,b,c)

tripleOp[Int,Double](23, 92, 14, 1.0 * _ / _ / _)
tripleOp[Int,Boolean](93, 92, 14, _ > _ + _)

Partially Applied Functions and Currying
------------------------------------------------------------
def factorOf(x: Int, y: Int) = y % x == 0

// Don't retain parameters
val f = factorOf _

// Retain some param i.e. partially apply the func
val multipleOf3 = factorOf(3, _: Int)
val y = multipleOf3(78)

// Currying
def factorOf(x: Int)(y: Int) = y % x == 0
val isEven = factorOf(2) _
val z = isEven(32)

Partial functions
------------------------------------------------------------
A partial function, as opposed to a total
function, only accepts a partial amount of all possible input values.

val statusHandler: Int => String = {
  case 200 => "Okay"
  case 400 => "Your error"
}

// statusHandler(401) will return MatchError