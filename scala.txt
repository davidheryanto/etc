# Frameworks for REST services
============================================================
============================================================
Play
Spray -> Going to be replaced with Akka-HTTP
http4s (functional idiom, use scalaz-streams)

============================================================
============================================================

------------------------------------------------------------
Notes from Learning Scala Book
------------------------------------------------------------

# Checking type
============================================================
x.isInstanceOf[Int]

# String interpolation
==============================================================
println(s"Pi, using 355/113, is about $approx." )

printf
------
f"I wrote a new $item%.3s today"  # Print first 3 char of item
f"Enjoying this $item ${355/113.0}%.5f times today"

# Regex
==============================================================
"Froggy went a' courting" matches ".*courting"
"milk, tea, muck" replaceAll ("m[^ ]+k", "coffee")
"milk, tea, muck" replaceFirst ("m[^ ]+k", "coffee")

val input = "Enjoying this apple 3.14159 times today"
val pattern = """.* apple ([\d.]+) times .*""".r
val pattern(amountText) = input
val amount = amountText.toDouble

# Tuple: 1-based index
val info = (5, "Korben", true)
val name = info._2
# Key-value pairs in tuple
val red = "red" -> "0xff0000"

# If..Else
==============================================================
if (<Boolean expression>) <expression>

if (<Boolean expression>) <expression>
else <expression>

val max = if (x > y) x else y

# Match
==============================================================
<expression> match {
	case <pattern match> => <expression>
	[case...]
}

val x = 10; val y = 20
val max = x > y match {
 case true => x
 case false => y
}

val status = 500
val message = status match {
 case 200 => "ok"
 case 400 => {
   println("ERROR - we called the service incorrectly")
   "error"
 }
 case 500 => {
   println("ERROR - the service encountered an error")
   "error"
 }
}

# A pattern alternative: any of the patterns
==============================================================
case <pattern 1> | <pattern 2> .. => <one or more expressions>

val kind = day match {
  case "MON" | "TUE" | "WED" | "THU" | "FRI" => "weekday"
  case "SAT" | "SUN" => "weekend"
}

# Matching with Wildcard Patterns
==============================================================
val message = "Value Binding"
val status = message match {
  case "Ok" => 200
  case other => {
    println(s"Couldn't parse $other")
    -1
  }
}

val status = message match {
  case "Ok" => 200
  case _ => {
    println(s"Couldn't parse $message")
    -1
  }
}

# Matching with Pattern Guards
==============================================================
val response: String = null
response match {
  case s if s != null => println(s"Received '$s'")
  case s => println("Error! Received a null response")
}

# Matching Types with Pattern Variables
==============================================================
case <identifier>: <type> => <one or more expressions>

val x: Int = 12180
val y: Any = x
y match {
  case x: String => s"'x'"
  case x: Double => f"$x%.2f"
  case x: Float => f"$x%.2f"
  case x: Long => s"${x}l"
  case x: Int => s"${x}i"
}

# Loops
==============================================================
Iterating, filtering, value binding

<starting integer> [to|until] <ending integer> [by increment]

for (<identifier> <- <iterator>) [yield] [<expression>]

for (x <- 1 to 7) { println(s"Day $x:") } 

val days = for (x <- 1 to 7) yield { s"Day $x:" }
for (day <- days) print(day + ", ")

# Iterator Guard
============================================================
for (<identifier> <- <iterator> if <Boolean expression>) ...

val threes = for (i <- 1 to 20 if i % 3 == 0) yield i

val quote = "Faith,Hope,,Charity"
for {
	t <- quote.split(",")
	if t != null
	if t.size > 0
}
{ println(t) }

# Nested Iterators
============================================================
for { x <- 1 to 2 
      y <- 1 to 3 }
  { print(s"($x, $y) " ) }

# Value Binding: temporary variables inside expression block for current iter
============================================================
for (<identifier> <- <iterator>; <identifier> = <expression>) ...

val powersOf2 = for (i <- 0 to 8; pow = 1 << i) yield pow

# While and Do/While
============================================================
while (<Boolean expression>) statement

var x = 10; while (x > 0) x -= 1

val x = 0
do println(s"Here I am, x = $x") while (x > 0)

# Functions
============================================================
def <identifier>(<identifier>: <type>[, ... ]): <type> = <expression>

def multiplier(x: Int, y: Int): Int = { x * y }

Procedure: No return value
--------------------------
def log(d: Double): Unit = println(f"Got value $d%.2f")

Tail Recursive
--------------
@annotation.tailrec
def power(x: Int, n: Int, t: Int = 1): Int = {
  if (n < 1) t
  else power(x, n-1, x*t)
}

Calling Functions with Named Parameters
---------------------------------------
def greet(prefix: String, name: String) = s"$prefix $name"

val greeting2 = greet(name = "Brown", prefix = "Mr")

Vararg
------
def sum(items: Int*): Int = {
  var total = 0
  for (i <- items) total += i
  total
}

Parameter Groups
----------------
def max(x: Int)(y: Int) = if (x > y) x else y

val larger = max(20)(39)

Type Parameters
---------------
def <function-name>[type-name](parameter-name>: <type-name>): <type-name>...

def identity[A](a: A): A = a

val s: String = identity[String]("Hello")
val d: Double = identity[Double](2.717)

# Can infer the parameter type and returned type
val s = identity("Hello")  # s: String = Hello

Methods and Operators
---------------------
val d = 65.34
d.round
d.floor
d.compare(18.0)
d.+(2.7231)

Operator Notation:
d compare 18.0
d + 2.721
"staring" substring (1,4)

============================================================
First Order Functions
============================================================

Function Type:
([<type>, ...]) => <type>

def double(x: Int): Int = x*2
val myDouble: (Int) => Int = double
val myDouble = double _  // Equivalent

def max(a: Int, b: Int) = if (a > b) a else b
val maximize: (Int, Int) => Int = max

// Function with no input
def logStart() = "=" * 50 + "\nStarting NOW\n" + "=" * 50
val start: () => String = logStart
println(start())

Higher-order functions
------------------------------------------------------------
A higher-order function is a function that has a value with a function type as an input parameter or return value.

// Only execute function f if s is not null
def safeStringOp(s: String, f: String => String) = {
  if (s != null) f(s) else s
}
def reverser(s: String) = s.reverse
safeStringOp(null, reverser)

Function Literals
------------------------------------------------------------
([<identifier>: <type>, ... ]) => <expression>

val doubler = (x: Int) => x * 2
val start = () => "=" * 50 + "\nStarting NOW\n" + "=" * 50

// Can define it inside of higher-order func invocation
safeStringOp("Ready", (s: String) => s.reverse)
safeStringOp("Ready", s => s.reverse)  // The type in function literal can be ignored, because it's already defined in safeStringOp

Placeholder syntax
------------------------------------------------------------
safeStringOp("Ready", _.reverse)

// Using type parameter
def tripleOp[A,B](a: A, b: A, c: A, f: (A, A, A) => B) = f(a,b,c)

tripleOp[Int,Double](23, 92, 14, 1.0 * _ / _ / _)
tripleOp[Int,Boolean](93, 92, 14, _ > _ + _)

Partially Applied Functions and Currying
------------------------------------------------------------
def factorOf(x: Int, y: Int) = y % x == 0

// Don't retain parameters
val f = factorOf _

// Retain some param i.e. partially apply the func
val multipleOf3 = factorOf(3, _: Int)
val y = multipleOf3(78)

// Currying
def factorOf(x: Int)(y: Int) = y % x == 0
val isEven = factorOf(2) _
val z = isEven(32)

Partial functions
------------------------------------------------------------
A partial function, as opposed to a total
function, only accepts a partial amount of all possible input values.

val statusHandler: Int => String = {
  case 200 => "Okay"
  case 400 => "Your error"
}

// statusHandler(401) will return MatchError

Invoking Higher-Order Functions with Function Literal Blocks
------------------------------------------------------------
// Traditional way
def safeStringOp(s: String, f: String => String) = {
  if (s!= null) f(s) else s
}

// Use function literal blocks
val uuid = java.util.UUID.randomUUID.toString

val timedUUID = safeStringOp(uuid, { s =>
  val now = System.currentTimeMillis
  val timed = s.take(24) + now
  timed.toUpperCase
})

// Clean up by using parameter groups
def safeString(s: String)(f: String => String) = {
  if (s!= null) f(s) else s
}

val timedUUID2 = safeString(uuid) { s => 
  val now = System.currentTimeMillis
  val timed = s.take(24) + now
  timed.toUpperCase
}

// Parameter by name and type param. Return type of f is the return type of timer
def timer[A](f: => A): A = {
  def now = System.currentTimeMillis
  val start = now; val a = f; val end = now
  println(s"Executed in ${end - start} ms")
  a
}

val veryRandomAmount = timer {
  util.Random.setSeed(System.currentTimeMillis)
  for (i <- 1 to 10000) util.Random.nextDouble
  util.Random.nextDouble
}

Exercise Typesafe
------------------------------------------------------------
def conditional[A](x: A, p: A => Boolean, f: A => String): String = {
  if (p(x)) f(x) else ""
}

def typeSafely(i: Int): String = {
  val a1 = conditional[Int](i, _ % 3 == 0, _ => "type")
  val a2 = conditional[Int](i, _ % 5 == 0, _ => "safe")
  val a3 = conditional[Int](i, _ % 3 > 0 && i % 5 > 0, x => s"$x")
  a1 + a2 + a3
}

val sequence = 1 to 100 map typeSafely
println(sequence.mkString("\n"))

============================================================
Collections
============================================================

List, Set, Maps
------------------------------------------------------------
val numbers = List(32, 95, 24, 21, 17)

// List: Immutable, implemented as Linked List
val numbers = List(32, 95, 24, 21, 17)
val colors = List("red", "green", "blue")
println(s"I have ${colors.size} colors: $colors")
colors.head
colors.tail
colors(2)

// Higher-order functions on collections
colors.foreach((c: String) => println(c))
colors.map((c: String) => c.size)
numbers.reduce((a: Int, b: Int) => a + b)

// Set
val unique = Set(10, 20, 30, 20, 20, 10)
val sum = unique.reduce((a: Int, b: Int) => a + b)

// Map
val colorMap = Map("red" -> 0xFF0000, "green" -> 0xFF00, "blue" -> 0xFF)
val redRGB = colorMap("red")
val cyanRGB = colorMap("green") | colorMap("blue")
val hasWhite = colorMap.contains("white")
for (pairs <- colorMap) {
  println(pairs)
}

// List in detail
val keyValues = List(('A', 65), ('B', 66), ('C', 67))
keyValues(0)

val primes = List(2, 3, 5, 7, 11, 13)
var i = primes
while (!i.isEmpty) {
  print(i.head + ", "); i = i.tail
}

def visit(i: List[Int]) {
  if (i.size > 0) {
    print(i.head + ",")
    visit(i.tail)
  }
}
visit(primes)

// Check end of list with Nil
while (i != Nil) {
  print(i.head + ","); i = i.tail
}

// Various List methods
val numbers = 1 :: 2 :: 3 :: Nil

val first = Nil.::(1)
val second = 2 :: first
second.tail == first  // Returns true

List(1, 2) ::: List(2, 3)

List(1, 2) ++ Set(3, 4, 3)

List(1, 2) == List(1, 2)

List(3, 5, 4, 3, 4).distinct

List('a', 'b', 'c', 'd') drop 2

List(23, 8, 14, 21) filter (_ > 18)

List(List(1, 2), List(3, 4)).flatten

List(1, 2, 3, 4, 5) partition (_ < 3)

List(1, 2, 3).reverse

List(2, 3, 5, 7) slice (1, 3)  // Exclude the end index

List("apple", "to") sortBy (_.size)

List("apple", "to").sorted

List(2, 3, 5, 7) splitAt 2

List(2, 3, 5, 7, 11, 13) take 3

List(1, 2) zip List("a", "b")

// Corollary to ::, drop, take
// Faster to use operations on the start of the list rather than the last
val appended = List(1, 2, 3, 4) :+ 5
val suffix = appended takeRight 3
val middle = suffix dropRight 2

List mapping
------------------------------------------------------------
List(0, 1, 0) collect {case 0 => "ok"}
List("milk,tea") flatMap (_.split(','))
List("milk","tea") map (_.toUpperCase)

Reducing List
------------------------------------------------------------
List(41, 59, 26).max
List(5, 6, 7).product
List(34, 29, 18) contains 29
List(0, 4, 3) endsWith List(4, 3)
List(24, 17, 32) exists (_ < 18)
List(24, 17, 32) forall (_ < 18)
List(0, 4, 3) startsWith List(0)

def contains(x: Int, l: List[Int]): Boolean = {
  var a: Boolean = false
  for (i <- l) {
    if (!a) a = (i == x)
  }
  a
}
val included = contains(19, List(46,19,92))

// More general contains function. The exists function can be customised
def boolReduce(l: List[Int], start: Boolean)(f: (Boolean, Int) => Boolean): Boolean = {
  var a = start
  for (i <- l) a = f(a, i)
  a
}
val included_2 = boolReduce(List(46,19,92), false){ (a,i) => if (a) a else (i == 19)}

// Generalize even further: for any Types
def reduceOp[A,B](l: List[A], start: B)(f: (B, A) => B): B = {
  var a = start
  for (i <- l) a = f(a, i)
  a
}
val included_3 = reduceOp(List(46,19,92), false) {
  (a,i) => if (a) a else (i == 19)
}
// Operation not limited to Int,Boolean. Can even use sum
val answer = reduceOp(List(11.3,23.5,7.2), 0.0)(_ + _)