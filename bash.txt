# Loop with step
for i in {0..10..2}
do
  ..
done

# Looping through all lines in a file
# http://stackoverflow.com/questions/1521462/looping-through-the-content-of-a-file-in-bash
while read p; do
  echo $p
done < FILEPATH.txt
# Single line
while read p; do echo $p; done <users.txt

# Process all files with certain extension
# https://stackoverflow.com/questions/14505047/loop-through-all-the-files-with-a-specific-extension
for f in *.rar; do unar "$f"; done

# Pad zero in string
n=1
wget http://aolradio.podcast.aol.com/sn/SN-`printf %03d $n`.mp3

# Run command or get env var
${HOME}
$(echo foo)

# Make output bold
# https://stackoverflow.com/questions/2924697/how-does-one-output-bold-text-in-bash
bold=$(tput bold)
normal=$(tput sgr0)

# Change output color of echo
# https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux
Red          0;31     Light Red     1;31
Green        0;32     Light Green   1;32
Brown/Orange 0;33     Yellow        1;33
Blue         0;34     Light Blue    1;34
Purple       0;35     Light Purple  1;35

RED='\033[0;31m'
NC='\033[0m' # No Color
printf "I ${RED}love${NC} Stack Overflow\n"
# Using echo need this option -e: enable interpretation of backslash escapes
echo -e "I ${RED}love${NC} Stack Overflow"

# Color and bold
# May also need to set TERM=xterm-color for non-interactive terminal
COLOR="\033[0;32m$(tput bold)"
NO_COLOR="\033[0m$(tput sgr0)"
echo -e "${COLOR}I'm colourful and bold${NO_COLOR}I'm normal"

# Brace expansion 
# http://unix.stackexchange.com/questions/315963/bash-command-to-copy-before-cursor-and-paste-after
echo a{b,c,d{e,f,g}}
ab ac ade adf adg

# Check if env variable is set
# https://stackoverflow.com/questions/11686208/check-if-environment-variable-is-already-set
# https://stackoverflow.com/questions/2981878/checking-for-environment-variables
if [ -z "$VARIABLE" ]; then
    VARIABLE=...
fi
# Quick check return code
[ -z ${PATH} ]; echo $?  # Return 1
[ -z ${SHOULD_NOT_EXIST} ]; echo $?  # Return 0

# Paremeter substitution: If VARIABLE is not set, set it to 'abc'
VARIABLE="${VARIABLE:=abc}"

# Check if variable is set
# Note that in ./command abc def, $0 = command, $1 = abc, $2 = def
if [ -z $0 ]; then echo '0 is unset'; else echo '0 is set'; fi
if [ -z $1 ]; then echo '1 is unset'; else echo '1 is set'; fi
if [ -z $2 ]; then echo '2 is unset'; else echo '2 is set'; fi

# Check variable equals value
if [ "$1" == "something" ]; then

# Pass literal tab character with $'\t'
sort -t $'\t'

# Get exit code of last command
echo $?

# Get basename i.e. folder name without full path
basename $PWD